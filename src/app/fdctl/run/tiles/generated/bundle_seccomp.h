/* THIS FILE WAS GENERATED BY generate_filters.py. DO NOT EDIT BY HAND! */
#ifndef HEADER_fd_src_app_fdctl_run_tiles_generated_bundle_seccomp_h
#define HEADER_fd_src_app_fdctl_run_tiles_generated_bundle_seccomp_h

#include "../../../../../../src/util/fd_util_base.h"
#include <linux/audit.h>
#include <linux/capability.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/bpf.h>
#include <sys/syscall.h>
#include <signal.h>
#include <stddef.h>

#if defined(__i386__)
# define ARCH_NR  AUDIT_ARCH_I386
#elif defined(__x86_64__)
# define ARCH_NR  AUDIT_ARCH_X86_64
#elif defined(__aarch64__)
# define ARCH_NR AUDIT_ARCH_AARCH64
#else
# error "Target architecture is unsupported by seccomp."
#endif
static const unsigned int sock_filter_policy_bundle_instr_cnt = 64;

static void populate_sock_filter_policy_bundle( ulong out_cnt, struct sock_filter * out, unsigned int logfile_fd) {
  FD_TEST( out_cnt >= 64 );
  struct sock_filter filter[64] = {
    /* Check: Jump to RET_KILL_PROCESS if the script's arch != the runtime arch */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, arch ) ) ),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, ARCH_NR, 0, /* RET_KILL_PROCESS */ 60 ),
    /* loading syscall number in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, nr ) ) ),
    /* allow fsync based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_fsync, /* check_fsync */ 16, 0 ),
    /* simply allow getrandom */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_getrandom, /* RET_ALLOW */ 58, 0 ),
    /* allow epoll_create1 based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_epoll_create1, /* check_epoll_create1 */ 16, 0 ),
    /* allow eventfd2 based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_eventfd2, /* check_eventfd2 */ 17, 0 ),
    /* simply allow epoll_ctl */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_epoll_ctl, /* RET_ALLOW */ 55, 0 ),
    /* simply allow epoll_wait */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_epoll_wait, /* RET_ALLOW */ 54, 0 ),
    /* allow socket based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_socket, /* check_socket */ 16, 0 ),
    /* simply allow connect */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_connect, /* RET_ALLOW */ 52, 0 ),
    /* allow fcntl based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_fcntl, /* check_fcntl */ 20, 0 ),
    /* allow setsockopt based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_setsockopt, /* check_setsockopt */ 27, 0 ),
    /* allow getsockopt based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_getsockopt, /* check_getsockopt */ 38, 0 ),
    /* simply allow recvfrom */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_recvfrom, /* RET_ALLOW */ 48, 0 ),
    /* simply allow write */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_write, /* RET_ALLOW */ 47, 0 ),
    /* simply allow writev */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_writev, /* RET_ALLOW */ 46, 0 ),
    /* allow shutdown based on expression */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_shutdown, /* check_shutdown */ 42, 0 ),
    /* simply allow close */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SYS_close, /* RET_ALLOW */ 44, 0 ),
    /* none of the syscalls matched */
    { BPF_JMP | BPF_JA, 0, 0, /* RET_KILL_PROCESS */ 42 },
//  check_fsync:
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, logfile_fd, /* RET_ALLOW */ 41, /* RET_KILL_PROCESS */ 40 ),
//  check_epoll_create1:
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, EPOLL_CLOEXEC, /* RET_ALLOW */ 39, /* RET_KILL_PROCESS */ 38 ),
//  check_eventfd2:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, EFD_CLOEXEC|EFD_NONBLOCK, /* RET_ALLOW */ 37, /* RET_KILL_PROCESS */ 36 ),
//  check_socket:
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, AF_INET, /* lbl_1 */ 0, /* RET_KILL_PROCESS */ 34 ),
//  lbl_1:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SOCK_STREAM|SOCK_CLOEXEC, /* lbl_2 */ 0, /* RET_KILL_PROCESS */ 32 ),
//  lbl_2:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, IPPROTO_TCP, /* RET_ALLOW */ 31, /* RET_KILL_PROCESS */ 30 ),
//  check_fcntl:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, F_GETFL, /* RET_ALLOW */ 29, /* lbl_3 */ 0 ),
//  lbl_3:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, F_SETFL, /* lbl_5 */ 0, /* lbl_4 */ 2 ),
//  lbl_5:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, O_RDWR|O_NONBLOCK, /* RET_ALLOW */ 25, /* lbl_4 */ 0 ),
//  lbl_4:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, F_DUPFD_CLOEXEC, /* RET_ALLOW */ 23, /* RET_KILL_PROCESS */ 22 ),
//  check_setsockopt:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SOL_SOCKET, /* lbl_7 */ 0, /* lbl_6 */ 2 ),
//  lbl_7:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SO_KEEPALIVE, /* RET_ALLOW */ 19, /* lbl_6 */ 0 ),
//  lbl_6:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SOL_TCP, /* lbl_9 */ 0, /* lbl_8 */ 2 ),
//  lbl_9:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, TCP_KEEPIDLE, /* RET_ALLOW */ 15, /* lbl_8 */ 0 ),
//  lbl_8:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SOL_TCP, /* lbl_10 */ 0, /* RET_KILL_PROCESS */ 12 ),
//  lbl_10:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, TCP_NODELAY, /* RET_ALLOW */ 11, /* RET_KILL_PROCESS */ 10 ),
//  check_getsockopt:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SOL_TCP, /* lbl_12 */ 0, /* lbl_11 */ 2 ),
//  lbl_12:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, TCP_NODELAY, /* RET_ALLOW */ 7, /* lbl_11 */ 0 ),
//  lbl_11:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SOL_SOCKET, /* lbl_13 */ 0, /* RET_KILL_PROCESS */ 4 ),
//  lbl_13:
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SO_ERROR, /* RET_ALLOW */ 3, /* RET_KILL_PROCESS */ 2 ),
//  check_shutdown:
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, SHUT_WR, /* RET_ALLOW */ 1, /* RET_KILL_PROCESS */ 0 ),
//  RET_KILL_PROCESS:
    /* KILL_PROCESS is placed before ALLOW since it's the fallthrough case. */
    BPF_STMT( BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS ),
//  RET_ALLOW:
    /* ALLOW has to be reached by jumping */
    BPF_STMT( BPF_RET | BPF_K, SECCOMP_RET_ALLOW ),
  };
  fd_memcpy( out, filter, sizeof( filter ) );
}

#endif
